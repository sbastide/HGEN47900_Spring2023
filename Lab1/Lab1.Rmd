---
title: "Lab 1: ChIP-seq and TF cooperative binding"
output: html_document
---

The goal of this lab is to perform exploratory analysis of a ChIP-exo dataset for TBX5, NKX2-5 and GATA4 generated in mouse (ES-derived) cardiomyocytes. The data comes from [this paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4769693/).

## Introduction: ChIP-seq

ChIP-seq is a method that allows to characterize protein-DNA interactions.  
**In class activity:** Can someone present the different steps of the ChIP-seq protocol? What is the difference with ChIP-exo?

**Question 1:**  
**a)** ChIP-seq experiments generate reads with higher density around the protein of interest's binding sites ("peaks"). If we split the reads between the forward (+) and reverse (-) strands, we see that the peaks are shifted. Can you explain why this is the case?  
**b)** For ChIP-seq, people usually use paired-end sequencing (both ends of the library fragments). With ChIP-exo, you only need to sequence one side. Can you explain why?

## Preparation

We load the packages required for the lab:  
- `dplyr` and `tidyr` are used for data maniputation,  
- `ggplot2` is used for plotting,   
- `patchwork` is used for arranging multiple `ggplot2` objects,  
- `edgeR` is used for data normalization,  
- `rtracklayer` has a bunch of tools that are useful for working with genomic data,  
- `GenomicRanges` allows us to work with a special data structure (GRanges) that facilitates some operations,  
- `marge` is used as an interface with the program `HOMER` that we use for motif analysis.  

We also set the path to `homer`.
```{r, message = FALSE}
options('homer_path' = '/data/programms/homer')
library(dplyr)
library(tidyr)
library(ggplot2)
library(edgeR)
# library(marge)
library(rtracklayer)
library(GenomicRanges)
library(patchwork)

exprs_thr <- 1
```

## Data download and processing

### 1. Download and pre-processing

The data is hosted on NCBI's GEO at [GSE77548](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE77548) under project [SRP062699](https://www.ncbi.nlm.nih.gov/sra?term=SRP062699). On the project page, one can download the list of sample by clicking on Sent *To > File > RunInfo*.  

Downloading the data takes a very long time. If you open a terminal on your computer, start a process and close the terminal, it will kill the process. One way to deal with that is to use [`tmux`](https://github.com/tmux/tmux/wiki). `tmux` is a terminal multiplexer that also allows to keep sessions running in the background if you close your terminal. You can start a new session by running:
```{bash, eval = FALSE}
tmux new -s lab1
```

The `Metadata` is the export from NCBI.
```{r, eval = FALSE}
metadata <- read.table("Metadata", fill = TRUE, head = TRUE, sep = "\t") %>% 
  arrange(bases) %>% 
  filter(LibraryStrategy == "ChIP-Seq") %>% 
  pull(Run) %>% 
  as.character() %>% 
  writeLines("AccessionList_ChIP_SRP062699")
```

Fetch data from the `AccessionList_ChIP_SRP062699` file using `fastq-dump.` \underline{Note:} we can also use the multithreaded `fasterq-dump`, but it doesn't allow to directly `gzip` the files and I am running low on space.
```{bash, eval = FALSE}
fastq-dump --split-files --gzip --skip-technical $(<AccessionList_ChIP_SRP062699)
# I ended up having to run fasterq-dump for speed, using the following:
fasterq-dump --split-files --threads 32 --skip-technical $(<AccessionList_ChIP_SRP062699)
pigz *.fastq
```
Each file took ~12-15 min (~24 h total).

Each file has a name of the form `SRRXXXXXXX.fastq.gz`, which is going to be painful to deal with later. So I renamed all the files so that their name reflects the different experimental conditions. For this, I created a (comma-separated) dictionary that maps file name to conditions.
```{r, eval = FALSE}
metadata %>% 
  select(Run, SampleName) %>% 
  mutate(Run = paste0(Run, ".fastq.gz"),
         SampleName = gsub("-", "_", SampleName) %>% paste0(., ".fastq.gz")) %>% 
  write.table(file = "mappingFile", sep = ",", quote = FALSE, 
              col.names = FALSE, row.names = FALSE)
```

This is what the file looks like:
```{bash}
head mappingFile
```

Then, using `awk` and `mv`, we can just rename everything at once. This command reads `mappingFile` using `,` as a delimiter. `$1` is the first column and `$2` is the second one. Then we just use `mv` to rename `$1` into `$2`.
```{bash, eval = FALSE}
awk -F',' 'system("mv " $1 " " $2)' mappingFile
```

### 2. Mapping

For the mapping, I am using `bwa`. As you remember, `bwa` needs to create an index (*ie.* Burrows-Wheeler transform) of the genome. This can easily be generated by running:
```{bash, eval = FALSE}
bwa index mm10.fa
```

I then wrote a script that maps all of the individual `fastq` files to the mouse genome. Instead of doing this, one could just write a loop in `bash`.
```{r, eval = FALSE}
basenames <- metadata %>% 
  arrange(bases) %>% 
  filter(LibraryStrategy == "ChIP-Seq") %>% 
  pull(SampleName) %>% 
  as.character() %>% 
  gsub("-", "_", .)
sapply(basenames, function(basename) {
  fastq_file <- paste0("fastq/", basename, ".fastq.gz")
  bam_file <- paste0("aln/", basename, ".bam")
  tmp_file <- paste0("aln/", basename, ".tmp")
  paste("bwa mem -t 48 /data/data/genomes/mm10.fa", fastq_file, "| samtools sort -@ 16 -O bam -T", tmp_file, "-o", bam_file)
}) %>% writeLines("map_reads.sh")
```

The script looks like this (\underline{Note:} there are no `##` in the actual script):
```{bash}
head map_reads.sh
```

And it can then be run easily with (this took 8 hours on 48 cores):
```{bash, eval = FALSE}
bash map_reads.sh
```

### 3. Peak calling and quantification.

There exists multiple methods to do peak calling. Among those, two commonly used methods are:  
- **MACS2**: models read numbers locally using a Poisson distribution based on a control sample (see slides).  
- **Hidden Markov Model (HMM)-based methods**: HPeaks, hiddenDomains, HMMRATAC, ... use an HMM to model read numbers across the genome (see slides). 

All of those methods return a **peak set**. A peak set is essentially a list of genomic coordinates (chromosome, start, end). Each peak is associated with a measure of significance (that is, how likely is it that the peak is actually noise). 

**Question 2:** By default, MACS2 returns fixed-size peaks. Can you explain how this simplifies the analysis and give one reason why this may be a problem?  

Because peak sets are called on individual replicates, we have to filter them and combine them into a single coherent peak set. This will enable us to quantify the binding of each TF to each of the defined regions. Typically, you would want to use [IDR](https://projecteuclid.org/journals/annals-of-applied-statistics/volume-5/issue-3/Measuring-reproducibility-of-high-throughput-experiments/10.1214/11-AOAS466.full) to merge and filter peak sets from different replicates. I couldn't get IDR to work so I used another criterion: 
```{r, eval = FALSE}
# First, we create a metadata table that contains the replicate information
metadata <- list.files("peaks") %>% 
  sapply(function(x) {
    condition = gsub("_[0-9]*$", "", x)
    replicate = gsub("^.*_", "", x)
    return(c(condition, replicate))
  }) %>% t %>% as.data.frame %>% 
  tibble::rownames_to_column("Sample") %>% 
  magrittr::set_colnames(c("Sample", "Condition", "Replicate"))

# Extracting individual conditions
conditions <- as.character(unique(metadata$Condition))

# We make sure to keep only peaks on large chromosomes (this removes peaks on unplaced scaffolds, ...)
allowed_chromosomes <- c(1:19, "X") %>% paste0("chr", .)

# A function to make peak sets
get_peak_set <- function(condition, qValue_threshold = 0) {
  peak_sets <- metadata %>% 
    filter(Condition == condition) %>% 
    pull(Sample) %>% 
    lapply(function(sample) {
      peaks <-read.table(paste0("peaks/", sample, "/", sample, "_peaks.narrowPeak"), stringsAsFactors = FALSE) %>% 
        magrittr::set_colnames(c("seqname", "start", "end", "name", "score", "strand", 
                                 "signalValue", "pValue", "qValue", "peak")) %>% 
        filter(seqname %in% allowed_chromosomes, qValue >= qValue_threshold) %>% 
        makeGRangesFromDataFrame(keep.extra.columns = TRUE)
      seqlevels(peaks) <- allowed_chromosomes
      return(peaks)
    })
  peak_coverage  <- coverage(do.call(c, peak_sets))
  covered_ranges <- peak_coverage %>% slice(lower = 2, rangesOnly = TRUE) %>% GRanges
  final_peak_set <- covered_ranges %>% reduce(min.gapwidth = 31)
  return(final_peak_set)
}
```

This function finds region in the genome that are covered by peaks in at least two replicates. It then merges peaks that are less than 30 bp apart. Then, we collapse peaks across conditions and resize them to ensure that they are the same size (250 bp). This results in a peak set of 172,461 peaks.
```{r, eval = FALSE}
peak_sets <- conditions %>% 
  lapply(get_peak_set, qValue_threshold = 0) %>% 
  do.call(c, .) %>% 
  reduce() %>%
  resize(250, fix = "center")
```

Peaks are written to a BED file for visualization and to a SAF file to serve as input for `featureCounts`.
```{r, eval = FALSE}
peak_sets %>% write.table(file = "final_peak_set.bed", quote = FALSE, col.names = FALSE, row.names = FALSE)
peak_sets %>% as.data.frame() %>% rowwise() %>% 
  mutate(name = paste(seqnames, start, end, sep = "_")) %>% 
  select(name, seqnames, start, end, strand) %>% 
  write.table(file = "final_peak_set.saf", quote = FALSE, col.names = FALSE, row.names = FALSE, sep = "\t")
```

Finally, we write and execute a script to count reads in the final peak set to obtain a count table.
```{r, eval = FALSE}
paste("featureCounts -T 48 -F SAF -a final_peak_set.saf -o ChIPseq_count_table.txt", 
      paste(list.files("aln", full.names = TRUE), collapse = " ")) %>% 
  writeLines("make_counts.sh")
```

```{bash, eval = FALSE}
bash make_counts.sh
```

## Data analysis

Let's first read in the count table and, once again, create a metadata table.
```{r}
count_table <- data.table::fread("ChIPseq_count_table_q10.txt", data.table = FALSE) %>% 
  tibble::column_to_rownames("Geneid") %>% 
  select(-c(1:5))
colnames(count_table) <- colnames(count_table) %>% gsub("aln/", "", .) %>% gsub("[.]bam", "", .)

metadata <- colnames(count_table) %>% 
  gsub("2_5", "2.5", .) %>% 
  strsplit(split = "_") %>% 
  # This takes care of the reChIP names
  lapply(function(x) if(length(x) == 5) {
    x[1] <- paste(x[1], x[2], sep = "_")
    return(x[-2])
  } else {return(x)}) %>% 
  do.call(rbind, .) %>% 
  as.data.frame() %>% 
  magrittr::set_colnames(c("IP", "Genotype", "Celltype", "Replicate")) %>% 
  tibble::add_column(Sample = colnames(count_table))
```

For normalization, we use edgeR's TMM. This takes care of the composition differences across different conditions.
```{r}
groups       <- metadata %>% select(1:3) %>% apply(1, paste, collapse = "_") %>% factor()
edgeR_object <- DGEList(counts = count_table, group = groups)
edgeR_object <- calcNormFactors(edgeR_object, method = "TMM")

TMM_table <- cpm(edgeR_object) # This actually gets TMMs, not CPMs.
TMM_by_condition <- levels(groups) %>% 
  lapply(function(condition) {
    x <- grep(condition, colnames(TMM_table))
    if(length(x) > 1) {
      return(rowMeans(TMM_table[,x]))
    } else {
      return(TMM_table[,x])
    }
  }) %>% do.call(cbind, .)
colnames(TMM_by_condition) <- levels(groups)
# saveRDS(TMM_by_condition, "TMM_by_condition_unfiltered_peaks.Rds")
```

For this analysis, we are only going to keep peaks that show "significant" binding in at least one of the conditions (we'll also focus only on cardiomyocytes "CM"). For this, we log-transform the data and keep peaks for which the maximum value is greater than one. We also discard all peaks that have a value of more than 1 for NKX2-5 in the NKO background. We keep 87,156/172,461 peaks.
```{r}
TMM_by_condition_filtered <- TMM_by_condition[,grep("_CM$", colnames(TMM_by_condition))] %>% 
  log1p %>% 
  {.[apply(., 1, max) > 1,]} %>% 
  as.data.frame %>% 
  filter(Nkx2.5_NKO_CM < 1)
```

### 1. Motif matching

As always, there are multiple ways to find motifs enriched in peaks. Here we will use a *known motifs* analysis (we could also have used a *de novo* motif analysis). For this, the usual options are `HOMER`, `MEME`, `rGADEM`, `GimmeMotifs` and some others. Here, we will use `HOMER` through the associated R package `marge`. For this particular task, we need to use the set of most significant peaks. Since we have not run the IDR analysis, we'll just use the most significant peaks from one of the replicates for each condition. 

For each transcription factor, we load the peak set, sort by q-value and take the top 500.
```{r, eval = FALSE}
Tbx5_top500_peaks <- fread("peaks/Tbx5_WT_CM_1/Tbx5_WT_CM_1_peaks.narrowPeak", data.table = FALSE) %>% 
  magrittr::set_colnames(c("seqname", "start", "end", "name", "score", "strand", 
                           "signalValue", "pValue", "qValue", "peak")) %>% 
  arrange(desc(qValue)) %>% head(500)

Nkx2.5_top500_peaks <- fread("peaks/Nkx2_5_WT_CM_1/Nkx2_5_WT_CM_1_peaks.narrowPeak", data.table = FALSE) %>% 
  magrittr::set_colnames(c("seqname", "start", "end", "name", "score", "strand", 
                           "signalValue", "pValue", "qValue", "peak")) %>% 
  arrange(desc(qValue)) %>% head(500)

Gata4_top500_peaks <- fread("peaks/Gata4_WT_CM_1/Gata4_WT_CM_1_peaks.narrowPeak", data.table = FALSE) %>% 
  magrittr::set_colnames(c("seqname", "start", "end", "name", "score", "strand", 
                           "signalValue", "pValue", "qValue", "peak")) %>% 
  arrange(desc(qValue)) %>% head(500)

marge::find_motifs_genome(x = Tbx5_top500_peaks,   genome = "mm10", path = "Tbx5_homer_results",   overwrite = TRUE)
marge::find_motifs_genome(x = Nkx2.5_top500_peaks, genome = "mm10", path = "Nkx2.5_homer_results", overwrite = TRUE)
marge::find_motifs_genome(x = Gata4_top500_peaks,  genome = "mm10", path = "Gata4_homer_results",  overwrite = TRUE)
```

**Question 3:** Explore the results of `HOMER`. Go into each folder and look at the `knownResults.html` file. It shows the top most enriched motifs in the peak sets defined above. As you can see, the motifs that show up are always the same, only the order changes.  
**a)** Provide a biological or technical explanation for this phenomenon.
**b)** Convert the data frames describing the peaks into `GRanges` (using `makeGRangesFromDataFrame()`), then use `findOverlaps()` to compare the different peak sets. Store the fraction of shared peaks in a 3x3 data frame and plot it using `ggplot2`. Does this help distinguishing between your two hypotheses in **a)**?   
**c)** If the biological hypothesis is true, how can we change the analysis to improve the signal (*ie.* try to remove the motifs that do not correspond to proteins that have been IPd)?   

### 2. Occupancy analysis

To help explore the data, I wrote the following function:
```{r}
# This function draws a heatmap for specific samples
# Inputs:
#   - col_to_keep: a vector of column names to be kept in the heatmap
#   - col_to_group: a vector of column used for the grouping
#   - blocks_to_keep: block indices to be kept in the final heatmap
#   - reorder_by_col: the name of the column to be used for reordering of the rows
# Ouput: a ggplot2 object 
plot_heatmap <- function(col_to_keep, col_to_group = NULL, blocks_to_keep = NULL, reorder_by_col = NULL) {
  
  TF_order <- col_to_keep %>% gsub("_WT.*$|_DKO.*$|_TKO.*$|_NKO.*$", "", .) %>% unique
  
  exprs_bin <- TMM_by_condition_filtered[,col_to_keep] %>% 
    {.[apply(., 1, max) > 1,]} %>% 
    {(. > 1)*1} %>% 
    as.data.frame %>% 
    tibble::rownames_to_column("Var1")
  
  exprs_nobin <- TMM_by_condition_filtered[,col_to_keep] %>% 
    {.[apply(., 1, max) > 1,]} %>%
    as.matrix %>% 
    reshape2::melt() %>% 
    left_join(exprs_bin, by = "Var1") %>% 
    mutate(TF = gsub("_WT.*$|_DKO.*$|_TKO.*$|_NKO.*$", "", Var2))
  
  if (is.null(col_to_group)) {
    col_to_group <- col_to_keep
  }
  
  exprs_nobin$blocks <- exprs_nobin[,col_to_group] %>%
    group_by_all() %>% 
    mutate(index = cur_group_id()) %>%
    ungroup() %>% pull(index)
  
  if (!is.null(blocks_to_keep)) {
    exprs_nobin <- exprs_nobin %>% 
      filter(grepl(blocks_to_keep, blocks))
  }
  
  if (!is.null(reorder_by_col)) {
    row_order <- exprs_nobin %>% filter(Var2 == reorder_by_col) %>% arrange(desc(value)) %>% pull(Var1) %>% rev
    exprs_nobin <- exprs_nobin %>% mutate(Var1 = factor(Var1, levels = row_order))
  }
  
  exprs_nobin <- exprs_nobin %>% 
    mutate(TF = factor(TF, levels = TF_order),
           Var2 = factor(Var2, levels = col_to_keep))
  
  exprs_nobin %>% 
    ggplot() +
    geom_tile(aes(x = Var2, y = Var1, fill = value)) +
    scale_fill_viridis_c(limits = c(0, 1.5), oob = scales::squish, breaks = c(0, 1.5), labels = c("Low", "High")) +
    scale_x_discrete(expand = c(0, 0)) +
    facet_grid(rows = vars(blocks), cols = vars(TF), scales = "free", space = "free") +
    guides(fill = guide_colorbar(frame.linewidth = 0.5, frame.colour = "black",
                                 title = "Occupancy", title.position = "top", title.hjust = 0.5, 
                                 barheight = 0.5, bbarwidth = 5)) +
    theme_void() +
    ylab("Peaks") +
    theme(strip.text = element_blank(), 
          legend.position = "top",
          axis.title.y = element_text(colour = "black", angle = 90),
          axis.text.x = element_text(colour = "black", angle = 90, vjust = 0.5, hjust = 1),
          panel.border = element_rect(fill = NA, linewidth = 1), 
          plot.margin = margin(1, 1, 1, 1, unit = "cm"))
}
```

Let's use it to look at the binding of TBX5, NKX2-5 and GATA4 in WT samples.
```{r, fig.align="center", fig.height=10, fig.width=3}
c("Tbx5_WT_CM", "Nkx2.5_WT_CM", "Gata4_WT_CM") %>% plot_heatmap()
```

In order to investigate the interdependecies between those transcription factors for binding, the authors have performed the same ChIP-exo experiment in mutant cardiomyocytes. NKO is an *Nkx2.5* knock-out, TKO is a *Tbx5* knockout and DKO is a double *Nkx2.5 Tbx5* knockout.

Let's look at the TBX5 binding sites in an NKO background:
```{r, fig.align="center", fig.height=10, fig.width=2}
c("Tbx5_WT_CM", "Tbx5_NKO_CM") %>% plot_heatmap()
```

**Question 4:** There are three categories of peaks: 1) peaks that gain TBX5 binding, 2) peaks that lose TBX5 binding and 3) sites that are unchanged (resistant to *Nkx2.5* knockout).  
**a)** Provide a biological mechanism for categories 1) and 2) and suggest either an experiment or an analysis to validate your hypothesis.  
**b)** Use the same kind of plot to show the dependency of the binding of NKX2.5 on TBX5.  
**bonus:** Make a heatmap (using the same function) that shows both the effect of NKO on TBX5 binding and TKO on NKX2.5 binding at the same time. (Roughly) what fraction of the binding sites show interdependence of TBX5 and NKX2.5 binding (co-bound in WT but lost if either of the TFs is lost)?

In order to gain more insight into this re-distribution of TBX5 in NKO cardiomyocytes, we can look at the individual instances of TBX5 motifs in TBX5 ChIP-exo peaks. For this, we use `FIMO` (part of the `MEME` suite).
```{bash, eval = FALSE}
/data/programms/meme-5.1.0/src/fimo --text PWM.meme /data/data/genomes/mm10.fa > PWM_scan_FIMO_output
```

```{r}
FIMO_output <- data.table::fread("PWM_scan_FIMO_output.gz", data.table = FALSE)

# This create a GRanges object that contains the category
exprs_bin <- TMM_by_condition_filtered[,c("Tbx5_WT_CM", "Tbx5_NKO_CM")] %>% 
  {.[apply(., 1, max) > 1,]} %>% 
  {(. > 1)*1} %>% 
  as.data.frame %>% 
  tibble::rownames_to_column("peak_id") %>% 
  group_by(Tbx5_WT_CM, Tbx5_NKO_CM) %>% 
  mutate(index = cur_group_id()) %>%
  ungroup() %>%
  separate(peak_id, into = c("chr", "start", "end"), sep = "_") %>% 
  makeGRangesFromDataFrame(keep.extra.columns = TRUE)

# This grabs all the Tbx5 motifs from the FIMO output and makes a GRanges object
Tbx5_motifs <- FIMO_output %>% 
  filter(motif_id == "Tbx5") %>% 
  makeGRangesFromDataFrame(seqnames.field = "sequence_name", 
                           keep.extra.columns = TRUE)

# This finds the motifs that fall insite ChIP-exo peaks
ov1 <- findOverlaps(Tbx5_motifs, exprs_bin)
```

We use this data to plot the distribution of the motif scores for TBX5 and the average density of TBX5 motifs in peaks for each category.
```{r}
p1 <- data.frame(score    = Tbx5_motifs$score[ov1@from],
                 category = exprs_bin$index[ov1@to]) %>% 
  ggplot() +
  geom_bar(aes(x = factor(category), fill = factor(score)), position = "fill") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_fill_viridis_d() +
  theme_classic() +
  xlab("Category") +
  ylab("Fraction of motifs") +
  labs(fill = "Motif score") +
  ggtitle("TBX5 binding motif score\nin TBX5 ChIP-exo peaks") +
  theme(axis.ticks.x = element_blank(), legend.position = "none")

p2 <- (table(exprs_bin$index[ov1@to]) / table(exprs_bin$index)) %>% 
  as.data.frame %>% 
  ggplot() +
  geom_bar(aes(x = Var1, y = Freq), stat = "identity", fill = "black") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0)) +
  xlab("Category") +
  ylab("TBX5 motif density in peaks (#motifs/peak)") +
  labs(fill = "Motif score") +
  ggtitle("TBX5 binding motif density\nin TBX5 ChIP-exo peaks") +
  theme_classic() +
  theme(axis.ticks.x = element_blank())
```

Similarly, we can plot the same type of data for NKX2.5 motifs in TBX5 peaks.
```{r}
# This grabs all the NKX2.5 motifs from the FIMO output and makes a GRanges object
Nkx2_5_motifs <- FIMO_output %>% 
  filter(motif_id == "Nkx2-5") %>% 
  makeGRangesFromDataFrame(seqnames.field = "sequence_name", 
                           keep.extra.columns = TRUE)

# This finds the motifs that fall insite ChIP-exo peaks
ov2 <- findOverlaps(Nkx2_5_motifs, exprs_bin)

p3 <- data.frame(score    = Nkx2_5_motifs$score[ov2@from],
                 category = exprs_bin$index[ov2@to]) %>% 
  ggplot() +
  geom_bar(aes(x = factor(category), fill = factor(score)), position = "fill") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_fill_viridis_d() +
  theme_classic() +
  xlab("Category") +
  ylab("Fraction of motifs") +
  labs(fill = "Motif score") +
  ggtitle("NKX2.5 binding motif score\nin TBX5 ChIP-exo peaks") +
  theme(axis.ticks.x = element_blank(), legend.position = "none")

p4 <- (table(exprs_bin$index[ov2@to]) / table(exprs_bin$index)) %>% 
  as.data.frame %>% 
  ggplot() +
  geom_bar(aes(x = Var1, y = Freq), stat = "identity", fill = "black") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0)) +
  xlab("Category") +
  ylab("NKX2.5 motif density in peaks (#motifs/peak)") +
  labs(fill = "Motif score") +
  ggtitle("NKX2.5 binding motif density\nin TBX5 ChIP-exo peaks") +
  theme_classic() +
  theme(axis.ticks.x = element_blank())
```

```{r, fig.align="center", fig.height=8, fig.width=8}
(p1 | p2) / (p3 | p4)
```

**Question 5:** Does this data support the mechanism you proposed in question 4? \underline{Important:} You don't need to go back and modify your answer to the previous question if it doesn't!  

**Question 6** Run the same analysis for NKX2.5 binding sites. Can you come to the same conclusions?  

**Bonus question:** Using the same functions, make a heatmap of the different categories of GATA4 peaks and how they behave in NKO and TKO backgrounds. Then look at the quality and density of TBX5 and NKX2.5 in those different categories. What logic can you infer from these analyses?  

**Bonus question:** Our final peak sets contains over 80,000 peaks. A fraction of those peaks could be noise. Replicate the same analysis using the count table `ChIPseq_count_table_q10.txt` as a starting point. This corresponds to a higher stringency on what is considered a peak and only contains ~58,000 peaks. How do the results vary?

**Question 7:** The [paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4769693/) uses "footprints" for their analysis. Describe their footprint-based analysis and critically highlight the differences with our peak-based analysis. How do they filter footprints? If you can, point out the caveats of those two approaches.  

**Question 8:** The hypothesis put forward by the authors is that TBX5 and NKX2.5 (and potentially GATA4) cooperatively bind to DNA both to: 1) increase the affinity of the two proteins with their target sites, and 2) to prevent ectopic binding of their partner. Furthermore, they suggest that - among those whose motifs are often found in TBX5 and NKX2.5 peaks - additional TFs may play a role in stabilizing the complex or imparting specificity. Design an experiment (any kind of method is allowed, including mutant lines, etc) that would - as unambiguously as possible - address some of these claims. Describe how you would analyse the results of this experiment.


